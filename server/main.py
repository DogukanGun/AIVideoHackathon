import json
import os
import uuid
from typing import List
import PyPDF2
import ollama
import re
from eth_account import Account
from lighthouseweb3 import Lighthouse
from ollama import Client
from web3 import Web3
from dotenv import load_dotenv
from fastapi import FastAPI, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware


load_dotenv()


trial_time = 0


def generate_prompt_and_get_answer(text: str) -> str:
    """Generates prompt for the llm model and gets the summary of the agreement

    :param text: content of the agreement
    :return: the summary of the agreement
    """
    global response
    global trial_time
    prompt = """
    from this text of an program tell me what u understand. If you see this pattern text of text, 
    that means this is the name and surname of someone, the parsing of the person fullname must be name of surname
    and consider that an user might have multiple names like name name name of surname
    If you see two times this pattern, after ___ of surname the next coming is new person
    But before know that the program extracts the text from a pdf
    so could you give me this info by replacing %%%%

    1. Seller is : %%%%
    2. Buyer is: %%%% 
    3. Price is: %%%%
    Please do not use ** at output
    """
    user_message = "The text is:\n" + text
    client = Client(host='http://localhost:11434')
    try:
        res = ollama.pull("llama3")
        print("Res = ", res)
        response = client.chat(model='llama3', messages=[
            {
                'role': 'system',
                'content': prompt,
            },
            {
                'role': 'user',
                'content': user_message,
            },
        ])
    except:
        trial_time += 1
        if trial_time == 10:
            raise Exception
        print(str(trial_time) + " time tested.")
        generate_prompt_and_get_answer(text)
    return response['message']['content']


def extract_text_from_pdf(pdf_path: str) -> str:
    """Extracts the content from the pdf file by reading it

    :param pdf_path: the path of the pdf file in the processor
    :return: the content of the pdf
    """
    with open(pdf_path, 'rb') as file:
        reader = PyPDF2.PdfReader(file)
        text = ''
        for page_num in range(len(reader.pages)):
            page = reader.pages[page_num]
            text += page.extract_text()
        print("File is read")
        return text


def extract_sales_info(text) -> List[str]:
    """Prepare the parameters for the verify method

    :param text: the summary generated by llm model
    :return: the parameters for the verify method
    """
    pattern = r'Seller is:\s*([A-Za-z\s]+)|Buyer is:\s*([A-Za-z\s]+)|Price is:\s*([Â£\d,]+)'
    matches = re.findall(pattern, text)
    extracted_info = [match[0].strip() if match[0] else (match[1].strip() if match[1] else match[2]) for match
                      in matches]
    print("Info is extracted")
    return extracted_info


app = FastAPI()


@app.post("/verify")
async def upload_file(
        file: UploadFile = File(...)
):
    if file.content_type != "application/pdf":
        return {"error": "File must be a PDF"}

    # Define the file path to save the uploaded file
    unique_filename = f"{uuid.uuid4()}.pdf"
    file_location = f"./uploaded_files/{unique_filename}"

    # Create the directory if it doesn't exist
    os.makedirs(os.path.dirname(file_location), exist_ok=True)

    with open(file_location, "wb") as f:
        f.write(await file.read())

    pdf_text = extract_text_from_pdf(file_location)
    ai_res = generate_prompt_and_get_answer(pdf_text)
    output = extract_sales_info(ai_res)
    return output

app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"],
                   allow_credentials=True)

if __name__ == "__main__":
    import uvicorn
    from os import getenv

    host = getenv("HOST", "0.0.0.0")
    port = int(getenv("PORT", "8080"))
    uvicorn.run(app, host=host, port=port)
